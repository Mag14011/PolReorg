import numpy as np
import csv
from tqdm import tqdm

def read_xyz(file_path):
    """Read an XYZ file and return the atomic symbols and coordinates for all frames."""
    with open(file_path, 'r') as file:
        lines = file.readlines()

    frames = []
    i = 0
    while i < len(lines):
        num_atoms = int(lines[i].strip())
        symbols = []
        coords = []
        for line in lines[i + 2:i + 2 + num_atoms]:
            parts = line.split()
            symbols.append(parts[0])
            coords.append([float(x) for x in parts[1:4]])
        frames.append((symbols, np.array(coords)))
        i += num_atoms + 2

    return frames

def write_xyz(file_path, symbols, coords, append=False):
    """Write atomic symbols and coordinates to an XYZ file."""
    mode = 'a' if append else 'w'
    with open(file_path, mode) as file:
        file.write(f"{len(symbols)}\n")
        file.write("Generated by Python script\n")
        for symbol, coord in zip(symbols, coords):
            coord_str = ' '.join(f"{x:.6f}" for x in coord)
            file.write(f"{symbol} {coord_str}\n")

def measure_fit(ref_coords, mob_coords):
    """Calculate the best-fit transformation matrix (rotation and translation) that aligns the mobile coordinates to the reference coordinates."""
    ref_coords = np.array(ref_coords)
    mob_coords = np.array(mob_coords)
    centroid_ref = np.mean(ref_coords, axis=0)
    centroid_mob = np.mean(mob_coords, axis=0)
    ref_centered = ref_coords - centroid_ref
    mob_centered = mob_coords - centroid_mob
    H = np.dot(mob_centered.T, ref_centered)
    U, S, Vt = np.linalg.svd(H)
    R = np.dot(Vt.T, U.T)
    if np.linalg.det(R) < 0:
        Vt[-1, :] *= -1
        R = np.dot(Vt.T, U.T)
    t = centroid_ref - np.dot(R, centroid_mob)
    return R, t

def compute_rmsd(coords1, coords2):
    """Compute the RMSD between two sets of coordinates."""
    diff = coords1 - coords2
    return np.sqrt(np.mean(np.sum(diff**2, axis=1)))

def save_transformation_to_csv(file_path, frame_idx, R, t):
    """Save the transformation matrix (rotation and translation) to a CSV file."""
    with open(file_path, 'a', newline='') as csvfile:
        writer = csv.writer(csvfile)
        row = [frame_idx] + R.flatten().tolist() + t.tolist()
        writer.writerow(row)

def validate_input_files(ref_file, mob_file, mode):
    """Validate input files based on mode."""
    ref_frames = read_xyz(ref_file)
    mob_frames = read_xyz(mob_file)
    
    if mode == "qm_to_md":
        if len(mob_frames) != 1:
            raise ValueError("In qm_to_md mode, mobile file (QM) must contain exactly 1 frame")
        if len(ref_frames) < 1:
            raise ValueError("Reference file (MD) must contain at least 1 frame")
    elif mode == "md_to_qm":
        if len(ref_frames) != 1:
            raise ValueError("In md_to_qm mode, reference file (QM) must contain exactly 1 frame")
        if len(mob_frames) < 1:
            raise ValueError("Mobile file (MD) must contain at least 1 frame")
    else:
        raise ValueError("Mode must be either 'qm_to_md' or 'md_to_qm'")
    
    return ref_frames, mob_frames

def superimpose_and_save(ref_file, mob_file, output_file, rmsd_file, transformation_csv, 
                        mode="md_to_qm", frame_indices=None):
    """Superimpose structures based on specified mode and save results.

    Args:
        ref_file (str): Path to reference XYZ file
        mob_file (str): Path to mobile XYZ file
        output_file (str): Path to save combined XYZ output
        rmsd_file (str): Path to save RMSD values
        transformation_csv (str): Path to save transformation matrices
        mode (str): Either "qm_to_md" (single QM mobile onto MD trajectory) or 
                   "md_to_qm" (MD trajectory mobile onto single QM)
        frame_indices (array-like, optional): Specific frame indices to process.
                                            Applied to MD frames in either mode.

    Returns:
        str: Path to the CSV file containing transformation matrices
    """
    # Validate inputs and read structures
    ref_frames, mob_frames = validate_input_files(ref_file, mob_file, mode)
    
    # Setup based on mode
    if mode == "qm_to_md":
        single_struct = mob_frames[0]  # Single QM structure (mobile)
        multi_frames = ref_frames      # MD trajectory (reference)
        struct_desc = "QM structure onto MD frames"
    else:  # md_to_qm
        single_struct = ref_frames[0]  # Single QM structure (reference)
        multi_frames = mob_frames      # MD trajectory (mobile)
        struct_desc = "MD frames onto QM structure"
    
    # Determine which frames to process
    if frame_indices is not None:
        frames_to_process = [(idx, multi_frames[idx]) for idx in frame_indices if idx < len(multi_frames)]
        print(f"Processing {len(frames_to_process)} selected frames out of {len(multi_frames)} total frames...")
    else:
        frames_to_process = list(enumerate(multi_frames))
        print(f"Processing all {len(multi_frames)} frames...")
        
    # Prepare output files
    open(output_file, 'w').close()
    open(rmsd_file, 'w').close()
    with open(transformation_csv, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['MD_Frame', 'R11', 'R12', 'R13', 'R21', 'R22', 'R23', 
                        'R31', 'R32', 'R33', 't1', 't2', 't3'])
    
    # Process frames with progress bar
    for frame_idx, (frame_symbols, frame_coords) in tqdm(frames_to_process, 
                                                        desc=f"Superimposing {struct_desc}",
                                                        unit="frame"):
        if mode == "qm_to_md":
            ref_symbols, ref_coords = frame_symbols, frame_coords
            mob_symbols, mob_coords = single_struct
        else:  # md_to_qm
            ref_symbols, ref_coords = single_struct
            mob_symbols, mob_coords = frame_symbols, frame_coords
            
        # Calculate and apply transformation
        R, t = measure_fit(ref_coords, mob_coords)
        transformed_coords = np.dot(mob_coords, R.T) + t
        
        # Compute RMSD
        rmsd = compute_rmsd(ref_coords, transformed_coords)
        
        # Write outputs
        combined_symbols = ref_symbols + mob_symbols
        combined_coords = np.vstack([ref_coords, transformed_coords])
        write_xyz(output_file, combined_symbols, combined_coords, append=True)
        
        with open(rmsd_file, 'a') as rmsd_out:
            rmsd_out.write(f"Frame {frame_idx}: RMSD = {rmsd:.6f}\n")
            
        save_transformation_to_csv(transformation_csv, frame_idx, R, t)
    
    print("\nProcessing complete!")
    return transformation_csv

# Example usage:
if __name__ == "__main__":
    ref_file_path = "reference.xyz"
    mob_file_path = "mobile.xyz"
    output_xyz_path = "aligned_output.xyz"
    rmsd_output_path = "rmsd_output.txt"
    transformation_csv_path = "transformation_matrices.csv"
    
    # Example 1: Superimpose single QM structure onto selected MD frames
    selected_frames = [0, 2, 4]  # Process only frames 0, 2, and 4 from MD trajectory
    result_csv = superimpose_and_save(
        ref_file_path, mob_file_path, output_xyz_path, 
        rmsd_output_path, transformation_csv_path,
        mode="qm_to_md",  # QM structure (mobile) onto MD trajectory (reference)
        frame_indices=selected_frames
    )
    print(f"Transformation matrices saved to: {result_csv}")
    
    # Example 2: Superimpose MD trajectory onto single QM structure
    result_csv = superimpose_and_save(
        ref_file_path, mob_file_path, output_xyz_path, 
        rmsd_output_path, transformation_csv_path,
        mode="md_to_qm",  # MD trajectory (mobile) onto QM structure (reference)
        frame_indices=selected_frames
    )
    print(f"Transformation matrices saved to: {result_csv}")
